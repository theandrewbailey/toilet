CREATE SCHEMA IF NOT EXISTS toilet;
CREATE SCHEMA IF NOT EXISTS tools;
CREATE TABLE IF NOT EXISTS toilet.section (sectionid integer NOT NULL, name character varying(250) NOT NULL, CONSTRAINT section_pk PRIMARY KEY (sectionid));
CREATE SEQUENCE IF NOT EXISTS toilet.section_sectionid_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1 OWNED BY toilet.section.sectionid;
CREATE TABLE IF NOT EXISTS toilet.article (articleid integer NOT NULL, articletitle character varying(250) NOT NULL, etag character varying(250) NOT NULL, modified timestamp without time zone NOT NULL, posted timestamp without time zone NOT NULL, postedhtml character varying NOT NULL, postedmarkdown character varying NOT NULL, postedname character varying(250) NOT NULL, sectionid integer NOT NULL, comments boolean, description character varying(1000), imageurl character varying(1000), summary character varying(65000), url character varying(1000), postedamp character varying, CONSTRAINT article_pk PRIMARY KEY (articleid), CONSTRAINT article_fk FOREIGN KEY (sectionid) REFERENCES toilet.section(sectionid) ON UPDATE RESTRICT ON DELETE RESTRICT);
CREATE SEQUENCE IF NOT EXISTS toilet.article_articleid_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1 OWNED BY toilet.article.articleid;
CREATE TABLE IF NOT EXISTS toilet.comment (commentid integer NOT NULL, articleid integer NOT NULL, posted timestamp without time zone NOT NULL, postedhtml character varying NOT NULL, postedname character varying(250) NOT NULL, isapproved boolean, isspam boolean, postedmarkdown character varying, CONSTRAINT comment_pk PRIMARY KEY (commentid), CONSTRAINT comment_fk FOREIGN KEY (articleid) REFERENCES toilet.article(articleid) ON UPDATE RESTRICT ON DELETE RESTRICT);
CREATE SEQUENCE IF NOT EXISTS toilet.comment_commentid_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1 OWNED BY toilet.comment.commentid;
CREATE TABLE IF NOT EXISTS tools.exceptionevent (exceptioneventid integer NOT NULL, atime timestamp without time zone NOT NULL, description character varying NOT NULL, title character varying(65000) NOT NULL, pagerequestid integer, CONSTRAINT exceptionevent_pk PRIMARY KEY (exceptioneventid));
CREATE SEQUENCE IF NOT EXISTS tools.exceptionevent_exceptioneventid_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1 OWNED BY tools.exceptionevent.exceptioneventid;
CREATE TABLE IF NOT EXISTS tools.fileupload (filename character varying(1000) NOT NULL, atime timestamp without time zone NOT NULL, etag character(250) NOT NULL, filedata bytea NOT NULL, brdata bytea, gzipdata bytea, mimetype character varying(100) NOT NULL, url character varying(65000), CONSTRAINT fileupload_pk PRIMARY KEY (filename));
CREATE TABLE IF NOT EXISTS tools.honeypot (honeypotid integer NOT NULL, expiresatatime timestamp without time zone NOT NULL, ip character varying(100) NOT NULL, startedatatime timestamp without time zone NOT NULL, CONSTRAINT honeypot_pk PRIMARY KEY (honeypotid));
CREATE SEQUENCE IF NOT EXISTS tools.honeypot_honeypotid_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1 OWNED BY tools.honeypot.honeypotid;
CREATE TABLE IF NOT EXISTS tools.localization (key character varying(1000) NOT NULL, localecode character varying(100), value character varying(65000) NOT NULL, CONSTRAINT localization_pk PRIMARY KEY (key, localecode));
ALTER TABLE ONLY toilet.article ALTER COLUMN articleid SET DEFAULT nextval('toilet.article_articleid_seq'::regclass);
ALTER TABLE ONLY toilet.comment ALTER COLUMN commentid SET DEFAULT nextval('toilet.comment_commentid_seq'::regclass);
ALTER TABLE ONLY toilet.section ALTER COLUMN sectionid SET DEFAULT nextval('toilet.section_sectionid_seq'::regclass);
ALTER TABLE ONLY tools.exceptionevent ALTER COLUMN exceptioneventid SET DEFAULT nextval('tools.exceptionevent_exceptioneventid_seq'::regclass);
ALTER TABLE ONLY tools.honeypot ALTER COLUMN honeypotid SET DEFAULT nextval('tools.honeypot_honeypotid_seq'::regclass);
CREATE INDEX IF NOT EXISTS article_posted ON toilet.article USING btree (posted);
CREATE INDEX IF NOT EXISTS article_postedtime_sectionid ON toilet.article USING btree (sectionid, posted);
CREATE INDEX IF NOT EXISTS article_sectionid ON toilet.article USING btree (sectionid);
CREATE INDEX IF NOT EXISTS comment_articleid ON toilet.comment USING btree (articleid);
CREATE INDEX IF NOT EXISTS comment_articleid_postedtime ON toilet.comment USING btree (articleid, posted);
CREATE INDEX IF NOT EXISTS comment_postedtime ON toilet.comment USING btree (posted);
CREATE INDEX IF NOT EXISTS honeypot_expiredtime_ip ON tools.honeypot USING btree (ip, expiresatatime);
CREATE INDEX IF NOT EXISTS honeypot_expiretime ON tools.honeypot USING btree (expiresatatime);
CREATE INDEX IF NOT EXISTS honeypot_ip ON tools.honeypot USING btree (ip);
CREATE MATERIALIZED VIEW IF NOT EXISTS toilet.articlesearch AS SELECT article.articleid, article.posted, regexp_replace(regexp_replace((article.postedmarkdown)::text, '\"'::text, ''::text, 'g'::text), '!?\[\"?([^\"|\]]+?)\"?\]\(\S+?(?:\s\"?([^\"|\]]+?)\"?)?\)'::text, '\1 \2'::text, 'g'::text) AS searchabletext, ((setweight(to_tsvector((COALESCE(article.articletitle, ''::character varying))::text), 'A'::"char") || setweight(to_tsvector(COALESCE(regexp_replace(regexp_replace((article.postedmarkdown)::text, '\"'::text, ''::text, 'g'::text), '!?\[\"?([^\"|\]]+?)\"?\]\(\S+?(?:\s\"?([^\"|\]]+?)\"?)?\)'::text, '\1 \2'::text, 'g'::text), ''::text)), 'D'::"char")) || setweight(to_tsvector((COALESCE(article.description, ''::character varying))::text), 'D'::"char")) AS searchindexdata FROM toilet.article ORDER BY article.posted WITH NO DATA;
CREATE MATERIALIZED VIEW IF NOT EXISTS toilet.articlewords AS SELECT ts_stat.word FROM ts_stat('SELECT to_tsvector(''simple'', searchabletext) FROM toilet.articlesearch'::text) ts_stat(word, ndoc, nentry) ORDER BY ts_stat.word WITH NO DATA;
CREATE MATERIALIZED VIEW IF NOT EXISTS tools.filemetadata AS SELECT fileupload.filename, length(fileupload.filedata) AS datasize, length(fileupload.gzipdata) AS gzipsize, length(fileupload.brdata) AS brsize, fileupload.atime, fileupload.etag, fileupload.mimetype, fileupload.url FROM tools.fileupload WITH NO DATA;
CREATE INDEX IF NOT EXISTS articlewords_gin_index ON toilet.articlewords USING gin (word public.gin_trgm_ops);
CREATE INDEX IF NOT EXISTS articlewords_word ON toilet.articlewords USING btree (word);
CREATE INDEX IF NOT EXISTS filemetadata_index ON tools.filemetadata USING btree (filename);
CREATE OR REPLACE FUNCTION toilet.search_articles(initialterm text) RETURNS SETOF toilet.article LANGUAGE plpgsql AS $$ BEGIN RETURN QUERY SELECT r.* FROM toilet.articlesearch a JOIN toilet.article r on a.articleid=r.articleid, websearch_to_tsquery(initialterm) query WHERE query @@ a.searchindexdata ORDER BY ts_rank_cd(a.searchindexdata, query) DESC, r.posted; END $$;
CREATE OR REPLACE FUNCTION tools.update_filemetadata() RETURNS trigger LANGUAGE plpgsql AS $$ BEGIN REFRESH MATERIALIZED VIEW tools.filemetadata; ANALYZE tools.filemetadata; RETURN NEW; END $$;
CREATE OR REPLACE FUNCTION toilet.refresh_articlesearch() RETURNS void LANGUAGE plpgsql AS $$ BEGIN REFRESH MATERIALIZED VIEW toilet.articlesearch; REFRESH MATERIALIZED VIEW toilet.articlewords; ANALYZE toilet.articlewords; END $$;
DROP TRIGGER IF EXISTS update_filemetadata ON tools.fileupload;
CREATE TRIGGER update_filemetadata AFTER INSERT OR DELETE OR UPDATE ON tools.fileupload FOR EACH STATEMENT EXECUTE PROCEDURE tools.update_filemetadata();